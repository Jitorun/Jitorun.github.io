<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jitorun.top","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Vegetable chicken">
<meta property="og:type" content="website">
<meta property="og:title" content="Jitorun&#39;s Blog">
<meta property="og:url" content="https://jitorun.top/index.html">
<meta property="og:site_name" content="Jitorun&#39;s Blog">
<meta property="og:description" content="Vegetable chicken">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jitorun">
<meta property="article:tag" content="GOGOGO">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jitorun.top/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Jitorun's Blog</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Jitorun's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Vegetable chicken</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tag fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jitorun</p>
  <div class="site-description" itemprop="description">Vegetable chicken</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Jitorun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jitorun" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/28/HashMap(%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/HashMap(%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">关于HashMap（下)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-28 19:50:33 / 修改时间：19:51:08" itemprop="dateCreated datePublished" datetime="2021-02-28T19:50:33+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="关于HashMap（下）"><a href="#关于HashMap（下）" class="headerlink" title="关于HashMap（下）"></a>关于HashMap（下）</h1><h2 id="关于HashMap源码（下）"><a href="#关于HashMap源码（下）" class="headerlink" title="关于HashMap源码（下）"></a>关于HashMap源码（下）</h2><ul>
<li>在上篇关于HashMap（上)中我记录学习了散列表的实现、扰动函数、负载因子、扩容拆分，接下来开始记录学习HashMap的存储、删除、获取、遍历（会遇到我一直不大理解的红黑树，这篇文章做个梳理，加深理解）</li>
<li>首先，红黑树是在JDK1.8中引入到HashMap解决<strong>链表过长</strong>的问题，简单的说当链表长度大于等于8时，会将链表转化为红黑树（存在某些特殊情况，不一定会树化，**[MIN_TREEIFY_CAPACITY]**）</li>
</ul>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul>
<li>在上篇中，提到HashMap插入数据简单来讲就是通过Key值取得哈希再计算下标，然后存放进去，但这个过程会遇到一些问题<ul>
<li>哈希计算下标碰撞怎么办?</li>
<li>如果碰撞了是扩容数组还是把值存放成链表结构，让一个节点有多个值存放？</li>
<li>如果存放的数组链表过长，就会失去散列表的性能，怎么办？</li>
<li>想解决链表过长，什么时候使用树结构？哪种树？</li>
</ul>
</li>
<li>HashMap的插入流程如下<ul>
<li>首先进行哈希值扰动，获取一个新的哈希值。**(key == null)? 0 : (h = key.hashCode())^(h&gt;&gt;&gt;16)**</li>
<li>接下来判断tab是否为空或者长度为0，如果是则进行扩容操作  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tab=table)==<span class="keyword">null</span> ||(n = tab.length)==<span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></li>
<li>根据哈希值计算下标，如果对应下标正好没存放数据，则直接插入，否则覆盖。<strong>tab[i=(n-1)&amp;hash]</strong></li>
<li>判断tab[i]是否是树节点，是则向树中插入节点，否则向链表中插入数据</li>
<li>如果链表中插入节点时，链表长度大于等于8，则需要把链表转换为红黑树。<strong>treeifyBin(tab,hash)</strong></li>
<li>所有元素处理完后，判断是否超过阈值threshold，超过则扩容</li>
<li><strong>关于treeifyBin</strong>：这是个链表转树的方法,不是所有链表长度为8后都为转为树，还需要判断存放key值得数组桶长度是否小于64<strong>MIN_TREEIFY_CAPACITY</strong>，小于则需要扩容，扩容后链表上的数据会被拆分散列的相应桶节点上，也就把链表长度缩短了</li>
</ul>
</li>
</ul>
<h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><ul>
<li>HashMap散列表数据结构最大性能可以O（1）时间复杂度定位到元素，而因为哈希碰撞而不得已采用链表来存放同坐标下多组数据，如果需要从链表中定位到数据时间复杂度为O（n），因此JDK1.8中把过长链表（8个）优化为自平衡的红黑树结构，这样优化时间复杂度为O(logn）</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>扰动函数的使用，获取新的哈希值，与上面相同</li>
<li>下标计算，<strong>tab[(n-1)&amp;hash]</strong></li>
<li>确定了数组下标，接下来对红黑树和链表进行查找</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>删除的话与链表和树的删除相关</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>KeySet</li>
<li>EntrySet</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/28/HashMap(%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/HashMap(%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">关于HashMap（上)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-28 19:23:06 / 修改时间：19:27:34" itemprop="dateCreated datePublished" datetime="2021-02-28T19:23:06+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="关于HashMap（上）"><a href="#关于HashMap（上）" class="headerlink" title="关于HashMap（上）"></a>关于HashMap（上）</h1><h2 id="关于HashCode"><a href="#关于HashCode" class="headerlink" title="关于HashCode"></a>关于HashCode</h2><h3 id="为什么HashCode的计算逻辑中，以31作为乘数"><a href="#为什么HashCode的计算逻辑中，以31作为乘数" class="headerlink" title="为什么HashCode的计算逻辑中，以31作为乘数"></a>为什么HashCode的计算逻辑中，以31作为乘数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="number">0</span>&amp;&amp;value.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> val[]=value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;value.length;i++&#123;</span><br><span class="line">            h=<span class="number">31</span>*h+val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>31是一个奇质数，如果选择偶数会导致乘积运算时数据溢出</li>
<li>在二进制中，2的五次方是32，31*i==(i&lt;&lt;5)-i，乘积运算可以使用位运算来提升性能</li>
<li><strong>在通过大量测试下，乘数31的时候碰撞概率很小，基本稳定</strong>，虽然乘数更大比如199之类的，碰撞概率更小，但是这个范围值已经超过int范围，所以没有什么必要</li>
<li>同时在乘数31时，散列效果很明显，基本在每个范围都有数据存放</li>
</ul>
<h2 id="关于HashMap源码（上）"><a href="#关于HashMap源码（上）" class="headerlink" title="关于HashMap源码（上）"></a>关于HashMap源码（上）</h2><h3 id="一个简单的HashMap原型"><a href="#一个简单的HashMap原型" class="headerlink" title="一个简单的HashMap原型"></a>一个简单的HashMap原型</h3><ul>
<li>HashMap会先初始化一组字符串集合，然后定义一个数组用于存放字符串（数组初始化大小后面会提到），接下来循环存放数据，计算出每个字符串在数组中的位置<strong>key.hashCode()&amp;(tab.length - 1)</strong>,在存放过程中，如果遇到相同的元素，进行连接操作，模拟链表过程，最后输出存放结果。</li>
</ul>
<h3 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h3><ul>
<li>上述原型存在一些问题，比如如果元素位置不够，就会导致散列碰撞严重，因此就需要用到扰动函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>)? <span class="number">0</span> : (h = key.hashCode())^(h&gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为什么进行扰动函数进一步原因<ul>
<li>理论上来说字符串的hashCode是int类型，可以作为数组下标且不会出现碰撞，但事实上hashCode的取值范围为[-2147483648,2147483647]，40亿的长度，数组不可能初始化那么大</li>
<li>我们默认初始化的Map大小为16各长度，<strong>DEFAULT_INITIAL_CAPACITY=1&lt;&lt;4</strong>，所以获取的Hash值不能直接作为下标使用，需要与数组长度进行取模运算得到下标值</li>
<li>事实上，hashMap源码不只是直接获取哈希值，而是进行一次**(h = key.hashCode())^(h&gt;&gt;&gt;16)** 扰动计算，把哈希值右移16位，之后与原哈希值做异或运算，混合原哈希值高位和地位，增加了<strong>随机性</strong></li>
<li>总结：使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞</li>
</ul>
</li>
</ul>
<h3 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h3><ul>
<li>关于上述HashMap简单模型，我在阅读资料的时候大佬是说要开2的倍数，起初我并不理解原理，后来才明白&amp;上(tab.length - 1)这样做的好处</li>
<li><strong>保证不会发生数组越界</strong>：在HashMap和ConcurrentHashMap中，数组的长度按规定是2的N次方，也就是说数组长度二进制形式10000000….，而tab.length-1的二进制形式就是0111111…，最高位是0，与hash值相与，结果一定不会比数组长度大，<strong>不会发生数组越界</strong></li>
<li><strong>保证元素尽可能均匀分布</strong>：tab.length-1一定是个奇数，那么在二进制是01111…情况下，与数相与的结果多样性比与偶数的二进制10000…相与大得多，这样可以<strong>使哈希均匀分布，尽量减少哈希冲突，提高效率</strong></li>
<li>同时关于HashMap的初始化中，阈值threshold的大小到底怎么确定的呢</li>
<li>阈值threshold通过方法tableSizeFor进行计算，这个方法就是<strong>寻找比初始值大的最小的那个二进制数值</strong>，比如传入17，就找到32</li>
</ul>
<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><ul>
<li>既然上述提到了阈值，就不得不提到负载因子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li>
<li>在HashMap中，负载因子决定了数据量多少后进行扩容，比如准备了7个元素，最后三个位置空余，两个位置存放了两个元素，所以即使数据比数组容量大也不一定能正好把数组占满，某些位置会出现大量冲突，只能在该位置用链表存放，失去了Map数组的性能</li>
<li>所以要找到一个合理大小进行扩容，默认值0.75就是说当阈值容量占用了四分之三时要进行扩容，减少碰撞</li>
<li>说到扩容，就涉及到一个细节，怎么扩容？<ul>
<li>查完资料后，发现在JDK1.7中会重新计算哈希值，而在1.8中优化了，不再需要重新计算</li>
<li>在新的扩容中，<strong>原哈希值与扩容新增出来的长度X进行&amp;运算，如果值等于0，则下标位置不变，如果不为0，那么新的位置是原来位置加X</strong>，也就不用重新计算每一个数组中元素的哈希值。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">计算机网络复习（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-28 00:10:57" itemprop="dateCreated datePublished" datetime="2021-02-28T00:10:57+08:00">2021-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-26 13:54:02" itemprop="dateModified" datetime="2021-02-26T13:54:02+08:00">2021-02-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">基础复习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络复习（一）"><a href="#计算机网络复习（一）" class="headerlink" title="计算机网络复习（一）"></a>计算机网络复习（一）</h1><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><ul>
<li><p>A类地址:以0为开头，第一个字节范围1-126（1.0.0.0-126.255.255.255)</p>
</li>
<li><p>B类地址:以10为开头，第一个字节范围128-191</p>
</li>
<li><p>C类地址:以110为开头，第一个字节范围192-223</p>
</li>
<li><p>D类地址:以1110为开头，第一个字节范围224-239（<strong>作为多播使用</strong>）</p>
</li>
<li><p>E类地址：保留</p>
</li>
<li><p><strong>IP地址与子网掩码相与得到网络号</strong></p>
</li>
<li><p>主机号全为0的为网络号(eg:192.168.2.0)，全为1的为广播地址（eg：192.168.2.255）</p>
</li>
</ul>
<h2 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h2><ul>
<li>ARP是地址解析协议</li>
<li>首先每个主机都会在自己的ARP缓冲区建立一个ARP列表，用来表示IP地址和MAC地址（硬件地址）之间的对应关系</li>
<li>当源主机要发送数据时，首先就会检查ARP列表里有没有对应的IP地址的目的主机的MAC地址，有就可直接发送数据，如果没有，向本网段所有主机发送ARP数据包（<strong>包括源主机IP地址，源主机MAC地址，目的主机IP地址</strong>）</li>
<li>当本网段所欲主机收到ARP数据包时，先检查包中的IP地址是不是自己的，如果是，则先从包中取出源主机的IP和MAC地址写入到自己的ARP列表中，如果已经有了就覆盖，然后将自己的MAC地址写入ARP响应包，告诉源主机自己是它寻找的MAC地址，如果不是，则忽略数据包。</li>
<li>源主机收到ARP响应包时，将目的主机IP和MAC写入ARP列表，并利用这信息发送数据，如果源主机一直没有收到ARP响应包，则表示ARP查询失败。</li>
</ul>
<h2 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul>
<li>第一次握手：客户端发送syn包（syn=1，seq=x）到服务器，并进入到SYN_SENT状态，等待服务器确认</li>
<li>第二次握手：服务器收到syn包，先确认客户的SYN（ack=x+1），自己也发送一个SYN包（seq=y），也就是发送SYN+ACK包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包后向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul>
<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送（<strong>此时主动关闭方还可以接受数据</strong>）</li>
<li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK到队方，确认序号为收到序号+1（<strong>FIN会占用一个序号</strong>）</li>
<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送</li>
<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li>
</ul>
<h2 id="为什么不把第二次和第三次挥手合并起来，二者有何区别，为什么挥手要比握手多一次"><a href="#为什么不把第二次和第三次挥手合并起来，二者有何区别，为什么挥手要比握手多一次" class="headerlink" title="为什么不把第二次和第三次挥手合并起来，二者有何区别，为什么挥手要比握手多一次"></a>为什么不把第二次和第三次挥手合并起来，二者有何区别，为什么挥手要比握手多一次</h2><ul>
<li>因为服务器收到客户端断开连接请求时，可能还有一些数据没有发完，这时先回复ACK，表示已经收到了客户端的断开请求连接，等到数据发完之后再发FIN，这时再断开服务器到客户端的数据传送。只有等到服务端所有的报文都发送完了，才能发送FIN报文，因此不能一起发送。所以，需要四次挥手。</li>
</ul>
<h2 id="在浏览器中输入www-baidu-com后执行的过程"><a href="#在浏览器中输入www-baidu-com后执行的过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的过程"></a>在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com后执行的过程/">www.baidu.com后执行的过程</a></h2><ul>
<li>浏览器获取输入的域名<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
<li>浏览器向DNS请求解析<a target="_blank" rel="noopener" href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a></li>
<li>域名系统DNS解析出百度服务器的IP地址</li>
<li>浏览器与服务器建立TCP连接（默认端口号80）</li>
<li>浏览器发出HTTP请求，请求百度首页</li>
<li>服务器通过HTTP相应把首页文件发送给浏览器</li>
<li>TCP连接释放</li>
<li>浏览器将首页文件解析，将Web页显示给用户</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul>
<li>TCP提供面向连接的可靠的数据流传输，而UDP提供的是非面向连接的不可靠的数据流传输</li>
<li>TCP传输单位为TCP报文段，UDP为用户数据报</li>
<li>TCP注重数据安全，UDP传输数据快，安全性一般</li>
<li>TCP对应协议：</li>
<li>FTP:文件传输协议，21端口</li>
<li>SMTP：邮件传送协议，25端口</li>
<li>POP3：与SMTP对应，用于接受邮件，110端口</li>
<li>HTTP：超文本传输协议，从Web服务器传输超文本到本地浏览器的传送协议</li>
<li>UDP对应协议：</li>
<li>DNS：域名解析服务，将域名地址转换为IP地址，53端口</li>
<li>SNMP：简单网络管理协议，用来管理网络设备，161端口</li>
<li>TFTP，简单文件传输协议，69端口</li>
</ul>
<h2 id="DNS域名系统工作原理"><a href="#DNS域名系统工作原理" class="headerlink" title="DNS域名系统工作原理"></a>DNS域名系统工作原理</h2><ul>
<li>查询浏览器和操作系统缓存</li>
<li>请问本地域名服务器</li>
<li>本地域名服务器没有命中缓存，则请求根域名服务器</li>
<li>根域名服务器返回所查询域的主域名服务器</li>
<li>本地域名服务器请求主域名服务器，获取该域名的名称服务器</li>
<li>本地域名服务器向名称服务器请求域名-IP映射</li>
<li>缓存解析结果</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/28/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-28 00:10:57" itemprop="dateCreated datePublished" datetime="2021-02-28T00:10:57+08:00">2021-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-07 18:59:16" itemprop="dateModified" datetime="2021-01-07T18:59:16+08:00">2021-01-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并查集-Disjoin-Set-简介"><a href="#并查集-Disjoin-Set-简介" class="headerlink" title="并查集(Disjoin-Set)简介"></a>并查集(Disjoin-Set)简介</h1><ul>
<li>并查集用于处理动态连通性问题，最典型应用为<strong>求解最小生成树的Kruskal算法</strong></li>
<li>并查集支持查询(find)，合并(union)两个操作，在查询与合并中要<strong>维护权值变化</strong></li>
<li>并查集只回答两个结点是不是在一个连通分量中（也就是连通性问题），并不回答路径问题</li>
<li>如果一个问题具有传递性质，可以考虑用并查集</li>
<li>并查集最常见的一种设计思想：把同在一个连通分量中的结点组织成一个树形结构（代表元法）</li>
<li>并查集使用<strong>路径压缩</strong>与<strong>按秩合并</strong>解决树的高度增加带来的查询性能消耗问题<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2></li>
<li>一种方法是递归实现，可以利用栈来实现</li>
<li>查询之前会经过合并以保证结论的正确性，既不会出现高度为3的树来影响结果</li>
</ul>
<h2 id="LeetCode例题"><a href="#LeetCode例题" class="headerlink" title="LeetCode例题"></a>LeetCode例题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#399 除法求值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/evaluate-division</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> equationsSize = equations.size();</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(<span class="number">2</span>* equationsSize);</span><br><span class="line">        <span class="comment">// 第 1 步，预处理，将变量的值与id进行映射，使得并查集的底层使用数组实现，方便编码</span></span><br><span class="line">        Map&lt;String,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * equationsSize);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equationsSize; i++) &#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String var1 = equation.get(<span class="number">0</span>);</span><br><span class="line">            String var2 = equation.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(var1)) &#123;</span><br><span class="line">                hashMap.put(var1, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(var2)) &#123;</span><br><span class="line">                hashMap.put(var2, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第 2 步，查询</span></span><br><span class="line">        <span class="keyword">int</span> queriesSize = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queriesSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String var1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String var2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Integer id1 = hashMap.get(var1);</span><br><span class="line">            Integer id2 = hashMap.get(var2);</span><br><span class="line">            <span class="keyword">if</span> (id1 == <span class="keyword">null</span> || id2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                res[i] = -<span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i]=unionFind.isConnected(id1,id2);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 结点指向父结点的权值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">double</span>[] weight;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i]=i;</span><br><span class="line">                weight[i]=<span class="number">1.0d</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y ,<span class="keyword">double</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            weight[rootX] = weight[y]*value/weight[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x!=parent[x])&#123;</span><br><span class="line">                <span class="keyword">int</span> origin = parent[x];</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">                weight[x] *= weight[origin];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY)&#123;</span><br><span class="line">                <span class="keyword">return</span> weight[x] / weight[y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * #547省份数量</span></span><br><span class="line"><span class="comment"> * 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回矩阵中 省份 的数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/number-of-provinces</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; father;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numsOfSets = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        father = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        numsOfSets = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!father.containsKey(x))&#123;</span><br><span class="line">            father.put(x,<span class="keyword">null</span>);</span><br><span class="line">            numsOfSets++;<span class="comment">//省份数量增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = find(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY)&#123;</span><br><span class="line">            father.put(rootX,rootY);</span><br><span class="line">            numsOfSets--;<span class="comment">//此时连通量减一，既省份数量减少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root =x ;</span><br><span class="line">        <span class="keyword">while</span> (father.get(root)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root = father.get(root);<span class="comment">//寻找根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x!=root)&#123;</span><br><span class="line">            <span class="keyword">int</span> original = father.get(x);<span class="comment">//将x的父节点保存起来</span></span><br><span class="line">            father.put(x,root);<span class="comment">//将x与根节点连接（路径压缩）</span></span><br><span class="line">            x = original;<span class="comment">//将x的父节点重复x的操作直到根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumsOfSets</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numsOfSets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; isConnected.length;i++)&#123;</span><br><span class="line">            unionFind.add(i);<span class="comment">//将各省份放入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果i j两省连通，则合并</span></span><br><span class="line">                    unionFind.merge(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionFind.getNumsOfSets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如有新内容再更新"><a href="#如有新内容再更新" class="headerlink" title="如有新内容再更新"></a>如有新内容再更新</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/28/Springboot%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/Springboot%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Springboot原理初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-28 00:10:57" itemprop="dateCreated datePublished" datetime="2021-02-28T00:10:57+08:00">2021-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-26 21:59:39" itemprop="dateModified" datetime="2021-02-26T21:59:39+08:00">2021-02-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Springboot原理初探"><a href="#Springboot原理初探" class="headerlink" title="Springboot原理初探"></a>Springboot原理初探</h1><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><ul>
<li>spring-boot-dependencies:核心依赖在父工程中</li>
<li>引入springboot依赖时，不需要指定版本，因为有版本仓库</li>
</ul>
<h3 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动器就是Springboot的启动场景</li>
<li>比如spring-boot-starter-web，会帮我们自动导入web环境所有依赖</li>
<li>springboot会将所有的功能场景都变成一个个的启动器</li>
<li>要使用什么功能就找到对应启动器就可以——<strong>starter</strong></li>
</ul>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将Springboot应用启动</span></span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootConfiguration :Springboot配置</span><br><span class="line"> 	 @Configuration：Spring配置类</span><br><span class="line">	 @Component：也是Spring的组件</span><br><span class="line">@EnableAutoConfiguration：自动配置</span><br><span class="line">	@AutoConfigurationPackage：自动配置包</span><br><span class="line">		@Import(AutoConfigurationPackages.Registrar.class):导入选择器</span><br><span class="line">        @Import(AutoConfigurationImportSelector.class)：自动配置导入选择</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取所有的配置</span><br><span class="line">List&lt;String&gt; configurations &#x3D; getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取候选的配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">		List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you &quot;</span><br><span class="line">				+ &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">		return configurations;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/27/Java%E7%9A%84%E7%B1%BB%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/27/Java%E7%9A%84%E7%B1%BB%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">Java的类执行顺序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-27 17:58:49 / 修改时间：18:03:24" itemprop="dateCreated datePublished" datetime="2021-02-27T17:58:49+08:00">2021-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java的类执行顺序"><a href="#Java的类执行顺序" class="headerlink" title="Java的类执行顺序"></a>Java的类执行顺序</h1><ul>
<li>确定类变量的初始值。在类加载的准备阶段，会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</li>
<li>初始化入口方法。当进入类加载的初始化阶段后，会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</li>
<li>初始化类构造器。会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器执行。</li>
<li>初始化对象构造器。会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终执行。</li>
<li>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爷爷在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grandpa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是爷爷~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是爸爸~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是儿子~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Son(); 	<span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">爷爷在静态代码块</span><br><span class="line">爸爸在静态代码块</span><br><span class="line">儿子在静态代码块</span><br><span class="line">我是爷爷~</span><br><span class="line">我是爸爸~</span><br><span class="line">我是儿子~</span><br></pre></td></tr></table></figure>
<p>首先在入口这里实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。<br>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷」、「我是爸爸」、「我是儿子~」。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/02/27/JVM%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/27/JVM%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">JVM基础（一)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-27 17:34:08 / 修改时间：17:58:44" itemprop="dateCreated datePublished" datetime="2021-02-27T17:34:08+08:00">2021-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM基础（一）"><a href="#JVM基础（一）" class="headerlink" title="JVM基础（一）"></a>JVM基础（一）</h1><h2 id="Java虚拟机作用"><a href="#Java虚拟机作用" class="headerlink" title="Java虚拟机作用"></a>Java虚拟机作用</h2><ul>
<li>Java虚拟机可以解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码，Java 虚拟机与字节码文件（Class文件）绑定</li>
<li>事实上，Java虚拟机运行的是字节码文件，所以不一定只能运行Java代码，如果其他语言的代码能生成符合字节码规范的文件，也可以在Java虚拟机上运行</li>
</ul>
<h2 id="JVM中的编译器"><a href="#JVM中的编译器" class="headerlink" title="JVM中的编译器"></a>JVM中的编译器</h2><ul>
<li>前端编译器：最常见的就是javac编译器，将Java源代码编译为Java字节码文件</li>
<li>JIT编译器：将Java字节码编译为本地机器代码</li>
<li>AOT编译器：将源代码直接编译为本地机器码</li>
</ul>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ul>
<li>字节码文件结构是一组以8位字节为基础的二进制流，数据项目排列在Class文件中，中间无分隔符，有两种最基本的数据类型：无符号数和表</li>
</ul>
<h2 id="Java虚拟机内存结构"><a href="#Java虚拟机内存结构" class="headerlink" title="Java虚拟机内存结构"></a>Java虚拟机内存结构</h2><ul>
<li>Java虚拟机内存结构可以分成公有和私有两部分（依据《Java虚拟机规范》）<ul>
<li>公有部分指所有线程共享的部分，指Java堆，方法区，常量池</li>
<li>私有部分是每个线程的私有数据，包括PC寄存器，Java虚拟机栈，本地方法栈</li>
</ul>
</li>
</ul>
<h3 id="公有部分：Java堆，方法区，常量池"><a href="#公有部分：Java堆，方法区，常量池" class="headerlink" title="公有部分：Java堆，方法区，常量池"></a>公有部分：Java堆，方法区，常量池</h3><ul>
<li>Java堆指JVM划分出来的一块区域，专门用于<strong>实例对象的内存分配</strong>，几乎所有实例对象都在这里进行分配，极小部分属于栈上分配<ul>
<li>Java堆会根据对象存活时间的不同分为年轻代和老年代，年轻代在经历指定次数的GC后，在下次GC时进入老年代</li>
<li>Java堆进行区域划分的目的其实是提高回收效率，存活时间短的对象往往更多，而垃圾回收时不得不对所有内存进行扫描，但其实有一部分对象，它们存活时间很长，对他们进行扫描完全是浪费时间</li>
</ul>
</li>
<li>方法区指存储Java类字节码数据的区域，存储了每个类的结构信息，如运行时常量池、字段、方法数据、构造方法等（常量池存放在方法区中）</li>
</ul>
<h3 id="私有部分：PC寄存器，Java虚拟机栈，本地方法栈"><a href="#私有部分：PC寄存器，Java虚拟机栈，本地方法栈" class="headerlink" title="私有部分：PC寄存器，Java虚拟机栈，本地方法栈"></a>私有部分：PC寄存器，Java虚拟机栈，本地方法栈</h3><ul>
<li>PC寄存器：任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中</li>
<li>Java 虚拟机栈：这个栈与线程同时创建，用来存储栈帧，即存储局部变量与一些过程结果的地方</li>
<li>本地方法栈： Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈</li>
</ul>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><ul>
<li>加载：代码数据加载到内存中</li>
<li>验证：加载完毕后，会进行验证是否符合JVM字节码规范</li>
<li><strong>准备</strong>：完成校验后，JVM 便会开始为类变量分配内存并初始化<ul>
<li>内存分配的对象：Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</li>
<li>初始化的类型：准备阶段会为类变量初始化，但是这里的初始化是指赋予该变量对应数据类型的零值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在准备阶段如果一个变量是常量(static final修饰)，则会直接赋值用户希望的值，而不是0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> test1=<span class="number">3</span>;<span class="comment">//准备阶段值为0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> test2 = <span class="number">4</span>;<span class="comment">//准备阶段值为4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*final修饰的类变量不会被改变</span></span><br><span class="line"><span class="comment">*而没有被修饰的类变量可能在初始化阶段或运行阶段发生变化</span></span><br><span class="line"><span class="comment">*所以也就没有必要在准备阶段就赋予所希望的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>解析:对引用进行解析</li>
<li><strong>初始化</strong>：JVM 会根据语句执行顺序对类对象进行初始化<ul>
<li>一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化（<strong>需要使用时再回来看，不必硬背</strong>）：<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>
</ul>
</li>
</ul>
</li>
<li>使用：JVM开始执行用户的程序代码</li>
<li>卸载：JVM开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2021/01/05/java_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/05/java_list/" class="post-title-link" itemprop="url">Java的List</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-05 19:23:13 / 修改时间：19:28:30" itemprop="dateCreated datePublished" datetime="2021-01-05T19:23:13+08:00">2021-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="List用法"><a href="#List用法" class="headerlink" title="List用法"></a>List用法</h1><h2 id="List接口定义常用方法"><a href="#List接口定义常用方法" class="headerlink" title="List接口定义常用方法"></a>List接口定义常用方法</h2><ul>
<li><p>List接口是继承Collection接口，所以Collection集合中有的方法，List集合也继承过来。</p>
</li>
<li><p>List接口的常用实现类有ArrayList和LinkedList，在使用List集合时，通常情况下声明为List类型，实例化时根据实际情况的需要，实例化为ArrayList或LinkedList，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res1 &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F; 利用ArrayList类实例化List集合</span><br><span class="line">List&lt;String&gt; res2 &#x3D; new LinkedList&lt;String&gt;();&#x2F;&#x2F; 利用LinkedList类实例化List集合</span><br></pre></td></tr></table></figure>
</li>
<li><p>add用法</p>
<ul>
<li>void add(int index, E element)<ul>
<li>index为插入的位置，element为插入内容，没有指定插入位置时，默认从尾部添加</li>
</ul>
</li>
</ul>
</li>
<li><p>Arraylist.aslist</p>
<ul>
<li>Java中使用Arrays.asList初始化ArrayList</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">以下为LeetCode的例题</span><br><span class="line"></span><br><span class="line">#830</span><br><span class="line">在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</span><br><span class="line">例如，在字符串 s &#x3D; &quot;abbxxxxzyy&quot;中，就含有 &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot; 和 &quot;yy&quot; 这样的一些分组。</span><br><span class="line">分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 &quot;xxxx&quot; 分组用区间表示为 [3,6] 。</span><br><span class="line">我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</span><br><span class="line">找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;positions-of-large-groups</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if ((i&#x3D;&#x3D;s.length()-1)||s.charAt(i)!&#x3D;s.charAt(i+1))&#123;</span><br><span class="line">                if (count&gt;&#x3D;3)&#123;</span><br><span class="line">                    res.add(Arrays.asList(i-count+1,i));</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                count&#x3D;1;    </span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后续学习继续更新"><a href="#后续学习继续更新" class="headerlink" title="后续学习继续更新"></a>后续学习继续更新</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2020/12/12/OS7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/12/OS7/" class="post-title-link" itemprop="url">OS第七章设备管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-12 20:37:42 / 修改时间：21:21:18" itemprop="dateCreated datePublished" datetime="2020-12-12T20:37:42+08:00">2020-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">课程复习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第7章-设备管理"><a href="#第7章-设备管理" class="headerlink" title="第7章 设备管理"></a>第7章 设备管理</h1><h2 id="分类-按数据组织方式、固有属性的分类原则"><a href="#分类-按数据组织方式、固有属性的分类原则" class="headerlink" title="分类(按数据组织方式、固有属性的分类原则)"></a>分类(按数据组织方式、固有属性的分类原则)</h2><ul>
<li>按设备的数据组织分类<ul>
<li>字符设备</li>
<li>块设备</li>
</ul>
</li>
<li>按设备的固有属性分类<ul>
<li>独占设备</li>
<li>共享设备</li>
</ul>
</li>
</ul>
<h2 id="设备独立性含义"><a href="#设备独立性含义" class="headerlink" title="设备独立性含义"></a>设备独立性含义</h2><ul>
<li>用户或程序中使用的设备与具体的物理设备无关，用户或程序使用的是逻辑设备，当进程运行时，由操作系统在逻辑设备与物理设备之间建立连接，即设备的分配，把这种设备使用方法的特点称为设备独立性</li>
</ul>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><ul>
<li>程序查询方式<ul>
<li>在执行一个进程的I/O操作时，处理器循环测试设备状态，状态为空闲时，处理器向设备控制器提交I/O操作，之后不断检查设备的标志寄存器，只有检查发现I/O操作完成后才执行后续指令</li>
</ul>
</li>
<li>中断方式<ul>
<li>某一事件的出现，要求处理器暂停当前进程的运行，而转向处理出现的事件，处理器完成该事件后才能继续原来的进程</li>
</ul>
</li>
<li>DMA方式<ul>
<li>对于块设备的I/O操作，采用中断方式时，处理器的利用率将受很大影响，采用DMA可以避免</li>
<li>DMA方式也称为直接存储器存取，通过硬件即DMA控制器，实现存储器与设备，设备与设备之间的数据传输，不需要处理器参与，可以实现大批量数据的快速传输</li>
</ul>
</li>
<li>通道方式<ul>
<li>DMA传输速度快，减少了处理器中断次数，但是因为DMA与处理器共享系统总线，影响了处理器利用率</li>
<li>对于大型计算机系统和现代微处理器，可以提供专用I/O处理机，即通道方式实现I/O操作</li>
</ul>
</li>
</ul>
<h2 id="I-O缓冲含义与目的"><a href="#I-O缓冲含义与目的" class="headerlink" title="I/O缓冲含义与目的"></a>I/O缓冲含义与目的</h2><ul>
<li>含义<ul>
<li>在设备的I/O操作中，利用一种存储部件或其中的部分，暂时存放要交换的数据，将来再把数据传输到目标位置，这种数据暂存的技术称为缓冲技术</li>
</ul>
</li>
<li>目的<ul>
<li>缓解设备和处理器之间速度不匹配的矛盾，提高系统工作的并行程度</li>
<li>减少I/O操作的次数</li>
<li>减少中断次数</li>
<li>提高系统及时性，方便用户操作</li>
</ul>
</li>
</ul>
<h2 id="设备分配相关数据结构"><a href="#设备分配相关数据结构" class="headerlink" title="设备分配相关数据结构"></a>设备分配相关数据结构</h2><ul>
<li>系统设备表</li>
<li>设备控制表</li>
<li>控制器控制表</li>
<li>通道控制表</li>
</ul>
<h2 id="磁盘驱动调度组成"><a href="#磁盘驱动调度组成" class="headerlink" title="磁盘驱动调度组成"></a>磁盘驱动调度组成</h2><ul>
<li>目的<ul>
<li>对于一组磁盘I/O操作的请求，系统按一定策略依次为各个I/O操作的请求服务，使得完成这组磁盘I/O操作所花的时间尽可能小</li>
</ul>
</li>
<li>由于同一个磁盘的每个I/O操作，存取一个物理块的时间大致相等，所以磁盘驱动调度时，通常不考虑传输时间T，并且把磁盘驱动调度分为<strong>移臂调度和旋转调度</strong>组成</li>
</ul>
<h2 id="移臂调度算法"><a href="#移臂调度算法" class="headerlink" title="移臂调度算法"></a>移臂调度算法</h2><ul>
<li>FCFS（先来先服务）<ul>
<li>按I/O操作请求提出的时间先后顺序，调度时选择最先提出的一个I/O操作请求</li>
<li>FCFS移臂调度算法可能导致频繁改变磁头方向</li>
<li>例如：假定某磁盘的一组I/O操作的访问提出的顺序依次是55、72、100、88、93、63（I/O操作请求所在的柱面号），当前磁盘位于90号。则服务顺序为90-55-72-100-88-93-63,移动距离35+17+28+12+5+27=124（跨越的柱面总数），其中磁头方向改变4次</li>
</ul>
</li>
<li>SSTF（最短寻道时间优先算法）<ul>
<li>按各请求所在的柱面，调度时选择距离当前磁头最近柱面的一个I/O操作请求</li>
<li>按上述例子，服务顺序为90-88-93-100-72-66-55，移动距离2+5+7+28+6+11=59，其中磁头改变方向2次</li>
</ul>
</li>
<li>扫描算法（SCAN）<ul>
<li>磁头从着陆区启动后，从内向外方向扫描移动，达到最外层柱面后改变方向从外向内扫描，在扫描移动过程中总是选择当前磁头方向上距离最近柱面的I/O操作，为其服务</li>
<li>例：假定某磁盘有256个柱面，当前磁头位于90号并且向柱面号小的方向移动，其余与上述例子相同，则服务顺序为90-88-72-66-55-0-93-100，移动距离190，磁头改变一次</li>
</ul>
</li>
<li>电梯算法<ul>
<li>是对扫描算法的一种改进，允许磁头中途改变方向</li>
<li>在服务过程中总是选择当前磁头方向上最近柱面的I/O操作，在当前方向上没有I/O操作而反方向上有时，立刻改变方向，并选择距离当前磁头方向最近柱面的I/O操作</li>
<li>如上述例子，服务顺序90-88-72-66-55-93-100，移动距离80，磁头改变一次</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jitorun.top/2020/12/12/OS6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jitorun">
      <meta itemprop="description" content="Vegetable chicken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jitorun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/12/OS6/" class="post-title-link" itemprop="url">OS第六章文件管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-12 19:50:22 / 修改时间：20:35:46" itemprop="dateCreated datePublished" datetime="2020-12-12T19:50:22+08:00">2020-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">课程复习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第6章-文件管理"><a href="#第6章-文件管理" class="headerlink" title="第6章 文件管理"></a>第6章 文件管理</h1><h2 id="文件系统的主要功能"><a href="#文件系统的主要功能" class="headerlink" title="文件系统的主要功能"></a>文件系统的主要功能</h2><ul>
<li>文件内容的组织<ul>
<li>文件内容的组织形式分为文件的逻辑结构和物理结构</li>
<li>逻辑结构侧重方便用户使用</li>
<li>物理结构侧重提高存储空间的利用率与存取速度</li>
</ul>
</li>
<li>文件和目录管理</li>
<li>文件存储空间管理</li>
<li>文件系统的接口</li>
<li>文件的共享与安全性</li>
</ul>
<h2 id="文件逻辑结构的分类"><a href="#文件逻辑结构的分类" class="headerlink" title="文件逻辑结构的分类"></a>文件逻辑结构的分类</h2><ul>
<li>流式文件<ul>
<li>文件内容按用户提供的数据顺序，以字符流方式组织，没有对内容进行结构上的划分</li>
</ul>
</li>
<li>记录式文件<ul>
<li>以数据在逻辑上的完整性含义为单位划分文件内容，每个单位称为一个逻辑记录，简称记录，记录式文件的文件内容是若干个记录的有序集合</li>
</ul>
</li>
</ul>
<h2 id="三类文件物理结构及其主要特点"><a href="#三类文件物理结构及其主要特点" class="headerlink" title="三类文件物理结构及其主要特点"></a>三类文件物理结构及其主要特点</h2><ul>
<li>连续结构<ul>
<li>也称顺序结构，对于一个文件的所有记录，系统按照记录顺序，将它们存放在依次相邻的物理块上，创建或保存一个文件时，系统根据文件的记录数，从外存中查找块数不少于文件记录数的连续空闲物理块</li>
<li>特点<ul>
<li>管理简单</li>
<li>存取速度快</li>
<li>存储空间连续分配，存储空间利用率不高</li>
<li>不方便文件内容的增加或删除</li>
</ul>
</li>
</ul>
</li>
<li>链接结构<ul>
<li>指定物理块的一个固定存储单元，例如每个块最后一个存储单元，作为链表的指针，指向同一个文件内容存储的下一个物理块，并规定指针为空表示该文件的物理块链表结束</li>
<li>特点<ul>
<li>非连续的存储分配，提高了存储空间的利用率</li>
<li>方便文件内容的增加或删除</li>
<li>只适合顺序存取，存取速度慢</li>
<li>指针信息造成物理块信息不完整，并导致数据无法控制</li>
</ul>
</li>
</ul>
</li>
<li>索引结构<ul>
<li>类似分页存储管理的页表一样，为外存储器上每一个文件建立一个索引表，登记了该文件的各个记录号（或主键）与物理块的对应关系</li>
<li>特点<ul>
<li>非连续的存储分配，提高了存储空间的利用率</li>
<li>方便文件内容的增加或删除</li>
<li>实现随机存取</li>
<li>索引表占用额外的存储空间</li>
<li>增加检索的开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="UNIX多级索引结构"><a href="#UNIX多级索引结构" class="headerlink" title="UNIX多级索引结构"></a>UNIX多级索引结构</h2><ul>
<li>UNIX把索引表分成4级，称为多级索引结构</li>
<li>UNIX中，每个文件都有一个数据结构，称为i-node，在i-node中定义了13个表项，记为i_addr[0]、i_addr[1]、…、i_addr[12]<ul>
<li>其中i_addr[0]~i_addr[9]的10个表项称为直接索引表</li>
<li>i_addr[10]为一次间接指针，指向保存一次间接索引表的物理块</li>
<li>i_addr[11]为二次间接指针，指向保存二次间接索引表的物理块</li>
<li>i_addr[12]为三次间接指针，指向保存三次间接索引表的物理块</li>
</ul>
</li>
<li>假定物理块长度为4KB，每个物理块号用4B表示<ul>
<li>这样对于直接索引表等级文件内容存储的前十个物理块，对于文件内容不超过40KB的小文件，只需要i-node直接索引表的10个表项就可以了</li>
<li>当文件内容超40KB时，使用一次间接索引表，一次间接索引表保存文件内容占用的各个物理块号，一个表项表示一个物理块号，占4B，所以一次间接索引表可以表示4KB/4B=1K即1024物理块，文件内容合计为4KB X 1024=4MB，在文件长度超过40KB而小于或等于40KB+4MB时，利用直接索引表和一次间接索引表可以实现对文件的管理</li>
<li>同理，二级索引表就是4GB，三级为4TB</li>
</ul>
</li>
<li><strong>理论上最大可达40KB+4MB+4GB+4TB（针对上述数据）</strong></li>
</ul>
<h2 id="二级目录结构及访问过程"><a href="#二级目录结构及访问过程" class="headerlink" title="二级目录结构及访问过程"></a>二级目录结构及访问过程</h2><ul>
<li>二级目录结构把目录分为两级：用户文件目录(UFD)和系统主目录(MFD)</li>
<li>访问过程<ul>
<li>按照用户名查找系统主目录，得到用户文件目录，接着按照文件名查找用户文件目录，得到文件的FCB，从而得到文件在外存中的存储位置</li>
</ul>
</li>
</ul>
<h2 id="树状目录结构、根目录、路径含义"><a href="#树状目录结构、根目录、路径含义" class="headerlink" title="树状目录结构、根目录、路径含义"></a>树状目录结构、根目录、路径含义</h2><ul>
<li>根目录<ul>
<li>根目录由系统自动建成，用户不能创建或删除</li>
</ul>
</li>
<li>现代操作系统都支持树状目录结构</li>
<li>“.”和”..”分别表示当前目录及其父目录</li>
</ul>
<h2 id="文件保护、保密的含义及基于主体权限的存取控制方式"><a href="#文件保护、保密的含义及基于主体权限的存取控制方式" class="headerlink" title="文件保护、保密的含义及基于主体权限的存取控制方式"></a>文件保护、保密的含义及基于主体权限的存取控制方式</h2><ul>
<li>文件保护<ul>
<li>含义<ul>
<li>防止文件内容被破坏，这种破坏指存储介质的物理损坏导致文件内容无法读取和用户的误操作造成文件内容的丢失</li>
</ul>
</li>
<li>措施<ul>
<li>备份与恢复两种措施</li>
</ul>
</li>
</ul>
</li>
<li>文件保密<ul>
<li>含义<ul>
<li>文件保密是对文件存取的控制，防止文件的非法访问</li>
</ul>
</li>
<li><strong>文件系统安全的核心是实现文件的保密</strong></li>
</ul>
</li>
<li>基于主体权限的存取控制方式<ul>
<li>根据主体对客体所拥有的访问属性而进行存取控制，因此属于自主访问策略（DAC)</li>
<li>主体权限的管理方法主要由三种：存取控制矩阵(PM)，访问控制表(ACL)，权能表(CL)</li>
<li>存取控制矩阵<ul>
<li>行表示主体，列表示客体</li>
<li>存取控制矩阵中可能存在大量的空元素或0</li>
</ul>
</li>
<li>存取控制表<ul>
<li>是存取控制矩阵的一种简化，为每个客体按列建立一个列表，用于登记可访问的各个用户及其访问属性</li>
</ul>
</li>
<li>权能表<ul>
<li>是存取控制矩阵的另一种简化，每个主体按行建立一个列表</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jitorun</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






</body>
</html>
